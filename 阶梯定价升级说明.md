# 执行器阶梯定价升级说明

> **版本**: v2.1.0  
> **更新日期**: 2025-10-27  
> **重要性**: ⭐⭐⭐⭐⭐ 核心功能升级

---

## 📋 变更概述

### 变更内容

将执行器模型中的**单一价格字段**替换为**阶梯定价结构** (`price_tiers`)，支持基于采购数量的灵活定价策略。

### 变更原因

1. ✅ **灵活定价** - 支持批量采购折扣
2. ✅ **价格透明** - 清晰展示不同数量档位的价格
3. ✅ **业务需求** - 满足实际销售中的阶梯定价需求
4. ✅ **数据结构优化** - 统一定价模型，便于维护

---

## 🔄 字段变更对比

### ❌ 旧结构（已删除）

```javascript
pricing: {
  base_price_normal: Number,    // 标准价格
  base_price_low: Number,       // 低价
  base_price_high: Number,      // 高价
  manual_override_model: String, // 手动装置型号
  manual_override_price: Number, // 手动装置价格
  seal_kit_price: Number        // 密封套件价格
}
```

**问题**:
- ❌ 只支持单一价格
- ❌ 无法表达批量折扣
- ❌ 价格和配件信息混在一起

---

### ✅ 新结构（当前）

#### 1. 阶梯定价字段 `price_tiers`

```javascript
price_tiers: [{
  min_quantity: {
    type: Number,           // 最小数量（起订量）
    required: true,
    min: 1
  },
  unit_price: {
    type: Number,           // 该数量档位的单价
    required: true,
    min: 0
  },
  price_type: {
    type: String,           // 价格类型（normal/low_temp/high_temp）
    enum: ['normal', 'low_temp', 'high_temp', 'standard'],
    default: 'normal'
  },
  notes: String             // 备注说明
}]
```

#### 2. 手动操作装置字段 `manual_override`

```javascript
manual_override: {
  model: String,            // 手动装置型号
  price: Number             // 手动装置价格
}
```

#### 3. 配件价格字段 `accessories_pricing`

```javascript
accessories_pricing: {
  seal_kit_price: Number    // 密封套件价格
}
```

**优势**:
- ✅ 支持多档位定价
- ✅ 清晰的字段分离
- ✅ 支持价格类型区分（标准/低温/高温）
- ✅ 便于扩展和维护

---

## 📖 使用示例

### 示例 1: 创建带阶梯定价的执行器

```javascript
const actuator = new Actuator({
  model_base: 'AT-SR52K8',
  series: 'AT',
  mechanism: 'Rack & Pinion',
  action_type: 'SR',
  
  // 阶梯定价配置
  price_tiers: [
    {
      min_quantity: 1,
      unit_price: 5280,
      price_type: 'normal',
      notes: '单件或小批量'
    },
    {
      min_quantity: 5,
      unit_price: 5016,    // 5% 折扣
      price_type: 'normal',
      notes: '5-9件享受5%折扣'
    },
    {
      min_quantity: 10,
      unit_price: 4752,    // 10% 折扣
      price_type: 'normal',
      notes: '10-19件享受10%折扣'
    },
    {
      min_quantity: 20,
      unit_price: 4488,    // 15% 折扣
      price_type: 'normal',
      notes: '20件以上享受15%折扣'
    }
  ],
  
  // 手动操作装置
  manual_override: {
    model: 'SD-1',
    price: 860
  },
  
  // 配件价格
  accessories_pricing: {
    seal_kit_price: 12
  }
});

await actuator.save();
```

---

### 示例 2: 根据采购数量获取价格

#### 使用内置方法 `getPriceByQuantity()`

```javascript
const actuator = await Actuator.findOne({ model_base: 'AT-SR52K8' });

// 采购 1 件
const price1 = actuator.getPriceByQuantity(1);
console.log(price1);
// 输出:
// {
//   unit_price: 5280,
//   min_quantity: 1,
//   total_price: 5280,
//   price_type: 'normal',
//   notes: '单件或小批量'
// }

// 采购 8 件
const price8 = actuator.getPriceByQuantity(8);
console.log(price8);
// 输出:
// {
//   unit_price: 5016,        // 使用了 5-9件的档位
//   min_quantity: 5,
//   total_price: 40128,      // 5016 × 8
//   price_type: 'normal',
//   notes: '5-9件享受5%折扣'
// }

// 采购 15 件
const price15 = actuator.getPriceByQuantity(15);
console.log(price15);
// 输出:
// {
//   unit_price: 4752,        // 使用了 10-19件的档位
//   min_quantity: 10,
//   total_price: 71280,      // 4752 × 15
//   price_type: 'normal',
//   notes: '10-19件享受10%折扣'
// }

// 采购 50 件
const price50 = actuator.getPriceByQuantity(50);
console.log(price50);
// 输出:
// {
//   unit_price: 4488,        // 使用了 20件以上的档位
//   min_quantity: 20,
//   total_price: 224400,     // 4488 × 50
//   price_type: 'normal',
//   notes: '20件以上享受15%折扣'
// }
```

---

### 示例 3: 获取所有价格档位

```javascript
const actuator = await Actuator.findOne({ model_base: 'AT-SR52K8' });

// 获取所有价格档位
const allTiers = actuator.getAllPriceTiers();
console.log(allTiers);
// 输出:
// [
//   { min_quantity: 1, unit_price: 5280, price_type: 'normal', ... },
//   { min_quantity: 5, unit_price: 5016, price_type: 'normal', ... },
//   { min_quantity: 10, unit_price: 4752, price_type: 'normal', ... },
//   { min_quantity: 20, unit_price: 4488, price_type: 'normal', ... }
// ]

// 只获取特定价格类型的档位
const normalTiers = actuator.getAllPriceTiers('normal');
```

---

### 示例 4: 支持不同温度等级的定价

```javascript
const actuator = new Actuator({
  model_base: 'AT-SR52K8-H',  // 高温型
  series: 'AT',
  
  price_tiers: [
    // 标准温度型号价格
    {
      min_quantity: 1,
      unit_price: 5280,
      price_type: 'normal'
    },
    {
      min_quantity: 10,
      unit_price: 4752,
      price_type: 'normal'
    },
    // 高温型号价格（价格更高）
    {
      min_quantity: 1,
      unit_price: 6336,        // 标准价 + 20%
      price_type: 'high_temp'
    },
    {
      min_quantity: 10,
      unit_price: 5702,        // 标准价 + 20%
      price_type: 'high_temp'
    }
  ]
});

// 获取标准型价格（10件）
const normalPrice = actuator.getPriceByQuantity(10, 'normal');
// unit_price: 4752

// 获取高温型价格（10件）
const highTempPrice = actuator.getPriceByQuantity(10, 'high_temp');
// unit_price: 5702
```

---

## 🔧 API 接口调整建议

### 控制器层修改建议

#### 1. 获取执行器价格（新增接口）

```javascript
// backend/controllers/actuatorController.js

// GET /api/actuators/:id/price?quantity=10&price_type=normal
exports.getActuatorPrice = async (req, res) => {
  try {
    const { id } = req.params;
    const { quantity = 1, price_type = 'normal' } = req.query;
    
    const actuator = await Actuator.findById(id);
    
    if (!actuator) {
      return res.status(404).json({
        success: false,
        message: '执行器不存在'
      });
    }
    
    const priceInfo = actuator.getPriceByQuantity(
      parseInt(quantity), 
      price_type
    );
    
    if (!priceInfo) {
      return res.status(404).json({
        success: false,
        message: '未配置价格信息'
      });
    }
    
    res.json({
      success: true,
      data: {
        actuator_model: actuator.model_base,
        quantity: parseInt(quantity),
        ...priceInfo
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};

// GET /api/actuators/:id/price-tiers?price_type=normal
exports.getPriceTiers = async (req, res) => {
  try {
    const { id } = req.params;
    const { price_type } = req.query;
    
    const actuator = await Actuator.findById(id);
    
    if (!actuator) {
      return res.status(404).json({
        success: false,
        message: '执行器不存在'
      });
    }
    
    const tiers = actuator.getAllPriceTiers(price_type);
    
    res.json({
      success: true,
      data: {
        actuator_model: actuator.model_base,
        price_tiers: tiers
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

#### 2. 选型接口中包含价格计算

```javascript
// backend/controllers/selectionController.js

exports.calculate = async (req, res) => {
  try {
    const { required_torque, working_pressure, quantity = 1 } = req.body;
    
    // ... 选型逻辑 ...
    
    // 为每个推荐的执行器添加价格信息
    const resultsWithPrice = recommendations.map(rec => {
      const priceInfo = rec.actuator.getPriceByQuantity(quantity);
      
      return {
        ...rec,
        pricing: priceInfo,
        manual_override: rec.actuator.manual_override,
        accessories: rec.actuator.accessories_pricing
      };
    });
    
    res.json({
      success: true,
      data: resultsWithPrice,
      count: resultsWithPrice.length
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
};
```

---

## 📊 数据迁移指南

### 方案 1: 从旧 `pricing` 迁移到 `price_tiers`

如果您有使用旧 `pricing` 字段的数据，可以使用以下脚本迁移：

```javascript
// scripts/migrate_pricing_to_tiers.js

const mongoose = require('mongoose');
const Actuator = require('../models/Actuator');

async function migratePricingToTiers() {
  try {
    await mongoose.connect(process.env.MONGODB_URI);
    
    // 查找所有有旧 pricing 数据的执行器
    const actuators = await Actuator.find({
      'pricing.base_price_normal': { $exists: true }
    });
    
    console.log(`找到 ${actuators.length} 个需要迁移的执行器`);
    
    for (const actuator of actuators) {
      // 创建基础阶梯定价（单价）
      const price_tiers = [
        {
          min_quantity: 1,
          unit_price: actuator.pricing.base_price_normal,
          price_type: 'normal',
          notes: '迁移自旧pricing字段'
        }
      ];
      
      // 如果有低价，添加批量档位
      if (actuator.pricing.base_price_low) {
        price_tiers.push({
          min_quantity: 5,
          unit_price: actuator.pricing.base_price_low,
          price_type: 'normal',
          notes: '批量价格（迁移）'
        });
      }
      
      // 迁移手动操作装置信息
      const manual_override = {
        model: actuator.pricing.manual_override_model,
        price: actuator.pricing.manual_override_price
      };
      
      // 迁移配件价格
      const accessories_pricing = {
        seal_kit_price: actuator.pricing.seal_kit_price
      };
      
      // 更新执行器
      actuator.price_tiers = price_tiers;
      actuator.manual_override = manual_override;
      actuator.accessories_pricing = accessories_pricing;
      
      // 删除旧字段
      actuator.pricing = undefined;
      
      await actuator.save();
      console.log(`✅ 已迁移: ${actuator.model_base}`);
    }
    
    console.log('\n迁移完成！');
    process.exit(0);
  } catch (error) {
    console.error('迁移失败:', error);
    process.exit(1);
  }
}

migratePricingToTiers();
```

**运行迁移**:
```bash
cd backend
node scripts/migrate_pricing_to_tiers.js
```

---

### 方案 2: 直接导入新格式数据

使用新的 CSV/Excel 模板，直接导入包含阶梯定价的数据。

**新模板示例** (`actuators_with_price_tiers.csv`):

```csv
model_base,series,mechanism,action_type,tier1_qty,tier1_price,tier2_qty,tier2_price,tier3_qty,tier3_price,manual_model,manual_price,seal_kit_price
AT-SR52K8,AT,Rack & Pinion,SR,1,5280,5,5016,10,4752,SD-1,860,12
AT-DA75K12,AT,Rack & Pinion,DA,1,8500,5,8075,10,7650,SD-2,1120,15
GY-SR100K15,GY,Rack & Pinion,SR,1,7200,5,6840,10,6480,SD-1,860,12
```

**导入脚本**:

```javascript
// scripts/import_actuators_with_tiers.js

const fs = require('fs');
const csv = require('csv-parser');
const Actuator = require('../models/Actuator');

async function importActuatorsWithTiers(csvFilePath) {
  const actuators = [];
  
  fs.createReadStream(csvFilePath)
    .pipe(csv())
    .on('data', (row) => {
      // 构建阶梯定价数组
      const price_tiers = [];
      
      if (row.tier1_qty && row.tier1_price) {
        price_tiers.push({
          min_quantity: parseInt(row.tier1_qty),
          unit_price: parseFloat(row.tier1_price),
          price_type: 'normal'
        });
      }
      
      if (row.tier2_qty && row.tier2_price) {
        price_tiers.push({
          min_quantity: parseInt(row.tier2_qty),
          unit_price: parseFloat(row.tier2_price),
          price_type: 'normal'
        });
      }
      
      if (row.tier3_qty && row.tier3_price) {
        price_tiers.push({
          min_quantity: parseInt(row.tier3_qty),
          unit_price: parseFloat(row.tier3_price),
          price_type: 'normal'
        });
      }
      
      const actuator = {
        model_base: row.model_base,
        series: row.series,
        mechanism: row.mechanism,
        action_type: row.action_type,
        price_tiers: price_tiers,
        manual_override: {
          model: row.manual_model,
          price: parseFloat(row.manual_price)
        },
        accessories_pricing: {
          seal_kit_price: parseFloat(row.seal_kit_price)
        }
      };
      
      actuators.push(actuator);
    })
    .on('end', async () => {
      // 批量插入
      await Actuator.insertMany(actuators);
      console.log(`✅ 成功导入 ${actuators.length} 个执行器`);
    });
}
```

---

## 🎨 前端展示建议

### 价格展示组件

```jsx
// frontend/src/components/PriceTierDisplay.jsx

import { Tag, Table } from 'antd';

const PriceTierDisplay = ({ priceTiers }) => {
  const columns = [
    {
      title: '数量范围',
      dataIndex: 'min_quantity',
      key: 'min_quantity',
      render: (qty, record, index) => {
        const nextQty = priceTiers[index + 1]?.min_quantity;
        return nextQty ? `${qty} - ${nextQty - 1}` : `${qty}+`;
      }
    },
    {
      title: '单价',
      dataIndex: 'unit_price',
      key: 'unit_price',
      render: (price) => `¥${price.toLocaleString()}`
    },
    {
      title: '折扣',
      key: 'discount',
      render: (_, record, index) => {
        if (index === 0) return <Tag color="default">标准价</Tag>;
        const basePrice = priceTiers[0].unit_price;
        const discount = ((basePrice - record.unit_price) / basePrice * 100).toFixed(1);
        return <Tag color="green">{discount}% OFF</Tag>;
      }
    },
    {
      title: '说明',
      dataIndex: 'notes',
      key: 'notes'
    }
  ];
  
  return (
    <Table 
      columns={columns} 
      dataSource={priceTiers}
      pagination={false}
      size="small"
    />
  );
};

export default PriceTierDisplay;
```

### 价格计算器组件

```jsx
// frontend/src/components/PriceCalculator.jsx

import { InputNumber, Card, Statistic } from 'antd';
import { useState } from 'react';

const PriceCalculator = ({ actuator }) => {
  const [quantity, setQuantity] = useState(1);
  
  // 获取当前数量的价格信息
  const getPriceInfo = () => {
    const tiers = actuator.price_tiers.sort((a, b) => b.min_quantity - a.min_quantity);
    for (const tier of tiers) {
      if (quantity >= tier.min_quantity) {
        return {
          unit_price: tier.unit_price,
          total: tier.unit_price * quantity,
          tier_min: tier.min_quantity
        };
      }
    }
    return null;
  };
  
  const priceInfo = getPriceInfo();
  
  return (
    <Card title="价格计算器" size="small">
      <div style={{ marginBottom: 16 }}>
        <label>采购数量：</label>
        <InputNumber 
          min={1} 
          value={quantity}
          onChange={setQuantity}
        />
      </div>
      
      {priceInfo && (
        <>
          <Statistic 
            title="单价" 
            value={priceInfo.unit_price} 
            prefix="¥"
          />
          <Statistic 
            title="总价" 
            value={priceInfo.total} 
            prefix="¥"
            valueStyle={{ color: '#3f8600' }}
          />
          <p style={{ marginTop: 8, color: '#888' }}>
            适用档位: {priceInfo.tier_min}件起
          </p>
        </>
      )}
    </Card>
  );
};

export default PriceCalculator;
```

---

## ✅ 测试清单

### 单元测试

```javascript
// backend/tests/actuator.price_tiers.test.js

const mongoose = require('mongoose');
const Actuator = require('../models/Actuator');

describe('Actuator Price Tiers', () => {
  let actuator;
  
  beforeAll(async () => {
    await mongoose.connect(process.env.MONGODB_URI_TEST);
  });
  
  beforeEach(async () => {
    actuator = new Actuator({
      model_base: 'TEST-SR52K8',
      series: 'TEST',
      action_type: 'SR',
      price_tiers: [
        { min_quantity: 1, unit_price: 5280, price_type: 'normal' },
        { min_quantity: 5, unit_price: 5016, price_type: 'normal' },
        { min_quantity: 10, unit_price: 4752, price_type: 'normal' }
      ]
    });
    await actuator.save();
  });
  
  afterEach(async () => {
    await Actuator.deleteMany({ series: 'TEST' });
  });
  
  test('应该返回正确的单件价格', () => {
    const price = actuator.getPriceByQuantity(1);
    expect(price.unit_price).toBe(5280);
    expect(price.total_price).toBe(5280);
  });
  
  test('应该返回正确的批量价格', () => {
    const price = actuator.getPriceByQuantity(8);
    expect(price.unit_price).toBe(5016);
    expect(price.total_price).toBe(40128);
  });
  
  test('应该返回正确的大批量价格', () => {
    const price = actuator.getPriceByQuantity(15);
    expect(price.unit_price).toBe(4752);
    expect(price.total_price).toBe(71280);
  });
  
  test('应该正确排序价格档位', () => {
    const tiers = actuator.getAllPriceTiers();
    expect(tiers[0].min_quantity).toBe(1);
    expect(tiers[1].min_quantity).toBe(5);
    expect(tiers[2].min_quantity).toBe(10);
  });
});
```

---

## 📝 注意事项

### ⚠️ 重要提醒

1. **数据迁移** - 如果有旧数据，必须先执行数据迁移脚本
2. **API兼容性** - 更新前端调用时注意新的数据结构
3. **价格配置** - 确保所有执行器都配置了 `price_tiers`
4. **测试验证** - 充分测试价格计算逻辑

### ✅ 最佳实践

1. **至少配置3个价格档位** - 单价、小批量、大批量
2. **合理设置折扣** - 通常 5%、10%、15% 递增
3. **添加备注说明** - 帮助销售人员理解价格策略
4. **定期审查价格** - 根据市场情况调整

---

## 🔗 相关文档

- [执行器模型文档](./backend/models/Actuator.js)
- [API接口文档](./完整API文档.md)
- [系统使用说明](./快速入门指南.md)

---

## 📞 技术支持

如有问题，请联系：
- 📧 **技术支持**: tech@cmax.com
- 📱 **开发团队**: dev@cmax.com

---

**文档版本**: v1.0.0  
**编写**: C-MAX技术团队  
**最后更新**: 2025-10-27

