# 定价函数升级使用指南

## 📅 更新时间
2025-10-28

## 🎯 更新内容

核心定价函数 `calculatePrice` 已升级，现在支持新的定价模式架构（固定价格 + 阶梯价格）。

---

## 📋 核心函数：calculatePrice

### 函数签名
```javascript
calculatePrice(productOrPriceTiers, quantity, priceType)
```

### 支持两种调用方式

#### ✅ 方式一：新方式（推荐）- 传入产品对象

```javascript
const product = {
  model_base: 'AT-SR52K8',
  pricing_model: 'tiered',  // 'fixed' 或 'tiered'
  base_price: 2500,
  price_tiers: [
    { min_quantity: 1, unit_price: 2500 },
    { min_quantity: 10, unit_price: 2300 },
    { min_quantity: 50, unit_price: 2100 }
  ]
};

const unitPrice = calculatePrice(product, 15);
// 返回: 2300 (单价)
```

#### ✅ 方式二：旧方式（向后兼容）- 传入价格数组

```javascript
const priceTiers = [
  { min_quantity: 1, unit_price: 5280, price_type: 'normal' },
  { min_quantity: 10, unit_price: 4752, price_type: 'normal' }
];

const priceInfo = calculatePrice(priceTiers, 8, 'normal');
// 返回: { 
//   unit_price: 5280, 
//   total_price: 42240,
//   min_quantity: 1,
//   quantity: 8,
//   price_type: 'normal'
// }
```

---

## 🆕 新增函数：getProductPriceInfo

获取产品的详细价格信息，包含应用的价格档位、节省金额、下一档推荐等。

### 函数签名
```javascript
getProductPriceInfo(product, quantity)
```

### 使用示例

#### 固定价格产品
```javascript
const product = {
  model_base: 'SF025',
  pricing_model: 'fixed',
  base_price: 1200
};

const priceInfo = getProductPriceInfo(product, 5);
console.log(priceInfo);
```

**输出**:
```javascript
{
  unit_price: 1200,
  total_price: 6000,
  quantity: 5,
  pricing_model: 'fixed',
  base_price: 1200
}
```

#### 阶梯价格产品
```javascript
const product = {
  model_base: 'AT-SR52K8',
  pricing_model: 'tiered',
  base_price: 2500,
  price_tiers: [
    { min_quantity: 1, unit_price: 2500, price_type: 'normal', notes: '标准价格' },
    { min_quantity: 10, unit_price: 2300, price_type: 'normal', notes: '批量优惠' },
    { min_quantity: 50, unit_price: 2100, price_type: 'normal', notes: '大批量优惠' }
  ]
};

const priceInfo = getProductPriceInfo(product, 15);
console.log(priceInfo);
```

**输出**:
```javascript
{
  unit_price: 2300,
  total_price: 34500,
  quantity: 15,
  pricing_model: 'tiered',
  base_price: 2500,
  
  // 当前应用的价格档位
  applied_tier: {
    min_quantity: 10,
    unit_price: 2300,
    price_type: 'normal',
    notes: '批量优惠'
  },
  
  // 节省金额（相对于基础价格）
  savings: {
    amount: 3000,        // 总节省金额 = (2500 - 2300) * 15
    rate: 8.00,          // 节省比例 8%
    per_unit: 200        // 每件节省 200 元
  },
  
  // 下一个价格档位推荐
  next_tier: {
    min_quantity: 50,
    unit_price: 2100,
    additional_quantity_needed: 35,    // 再买 35 件可达到下一档
    additional_savings_per_unit: 200   // 每件再节省 200 元
  },
  
  // 所有可用的价格档位
  available_tiers: [
    { min_quantity: 1, unit_price: 2500, price_type: 'normal', notes: '标准价格' },
    { min_quantity: 10, unit_price: 2300, price_type: 'normal', notes: '批量优惠' },
    { min_quantity: 50, unit_price: 2100, price_type: 'normal', notes: '大批量优惠' }
  ]
}
```

---

## 💡 实际应用场景

### 场景 1: 在 API 路由中使用

```javascript
// backend/routes/actuators.js

const { calculatePrice, getProductPriceInfo } = require('../utils/pricing');
const Actuator = require('../models/Actuator');

// 获取产品价格 API
router.get('/actuators/:id/price', async (req, res) => {
  try {
    const { id } = req.params;
    const { quantity = 1 } = req.query;
    
    // 从数据库获取产品
    const product = await Actuator.findById(id);
    
    if (!product) {
      return res.status(404).json({ error: '产品不存在' });
    }
    
    // 计算价格（简单方式）
    const unitPrice = calculatePrice(product, parseInt(quantity));
    
    res.json({
      model: product.model_base,
      quantity: parseInt(quantity),
      unit_price: unitPrice,
      total_price: unitPrice * parseInt(quantity)
    });
    
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 获取详细价格信息 API
router.get('/actuators/:id/price-detail', async (req, res) => {
  try {
    const { id } = req.params;
    const { quantity = 1 } = req.query;
    
    const product = await Actuator.findById(id);
    
    if (!product) {
      return res.status(404).json({ error: '产品不存在' });
    }
    
    // 获取详细价格信息
    const priceInfo = getProductPriceInfo(product, parseInt(quantity));
    
    res.json({
      model: product.model_base,
      series: product.series,
      price_info: priceInfo
    });
    
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 场景 2: 在选型算法中使用

```javascript
// backend/utils/selectionAlgorithm.js

const { calculatePrice } = require('./pricing');

function selectOptimalActuator(requirements, candidates) {
  const results = candidates.map(product => {
    const quantity = requirements.quantity || 1;
    
    // 计算该产品的价格
    const unitPrice = calculatePrice(product, quantity);
    const totalPrice = unitPrice * quantity;
    
    return {
      product: product,
      unit_price: unitPrice,
      total_price: totalPrice,
      // ... 其他选型参数
    };
  });
  
  // 按总价排序
  results.sort((a, b) => a.total_price - b.total_price);
  
  return results;
}
```

### 场景 3: 批量计算多个产品

```javascript
const { calculateBulkPrice } = require('../utils/pricing');

// 新方式：传入产品对象
const items = [
  { product: sfProduct1, quantity: 5 },
  { product: atProduct1, quantity: 15 },
  { product: gyProduct1, quantity: 30 }
];

const bulkPrice = calculateBulkPrice(items);
console.log(bulkPrice);
```

**输出**:
```javascript
{
  total_price: 125000,
  items_count: 3,
  total_quantity: 50,
  items: [
    {
      index: 0,
      quantity: 5,
      unit_price: 1200,
      subtotal: 6000,
      pricing_model: 'fixed'
    },
    {
      index: 1,
      quantity: 15,
      unit_price: 2300,
      subtotal: 34500,
      pricing_model: 'tiered'
    },
    {
      index: 2,
      quantity: 30,
      unit_price: 2800,
      subtotal: 84500,
      pricing_model: 'tiered'
    }
  ]
}
```

### 场景 4: 在前端显示价格

```javascript
// 前端请求价格信息
const response = await fetch(`/api/actuators/${productId}/price-detail?quantity=${quantity}`);
const data = await response.json();

// 显示价格信息
if (data.price_info.pricing_model === 'tiered') {
  console.log(`当前单价: ¥${data.price_info.unit_price}`);
  console.log(`总价: ¥${data.price_info.total_price}`);
  
  if (data.price_info.savings) {
    console.log(`相比基础价节省: ¥${data.price_info.savings.amount} (${data.price_info.savings.rate}%)`);
  }
  
  if (data.price_info.next_tier) {
    console.log(`提示: 再购买 ${data.price_info.next_tier.additional_quantity_needed} 件，每件可再节省 ¥${data.price_info.next_tier.additional_savings_per_unit}`);
  }
} else {
  console.log(`固定单价: ¥${data.price_info.unit_price}`);
  console.log(`总价: ¥${data.price_info.total_price}`);
}
```

---

## 🔄 定价模式判断逻辑

### 阶梯价格查找（Tiered Pricing）

当 `pricing_model === 'tiered'` 时，执行以下逻辑：

```javascript
// 1. 初始化为基础价格
let applicablePrice = product.base_price || 0;

// 2. 倒序遍历价格档位
for (let i = product.price_tiers.length - 1; i >= 0; i--) {
  // 3. 找到第一个满足数量要求的档位
  if (quantity >= product.price_tiers[i].min_quantity) {
    applicablePrice = product.price_tiers[i].unit_price;
    break;  // 找到即退出
  }
}

// 4. 返回适用的单价
return applicablePrice;
```

**示例**:
```javascript
// 假设价格档位如下：
price_tiers = [
  { min_quantity: 1, unit_price: 2500 },
  { min_quantity: 10, unit_price: 2300 },
  { min_quantity: 50, unit_price: 2100 }
]

// 数量 = 5
// 倒序遍历：50 (不满足) -> 10 (不满足) -> 1 (满足!)
// 返回: 2500

// 数量 = 15
// 倒序遍历：50 (不满足) -> 10 (满足!)
// 返回: 2300

// 数量 = 60
// 倒序遍历：50 (满足!)
// 返回: 2100
```

### 固定价格（Fixed Pricing）

当 `pricing_model === 'fixed'` 或未设置时：

```javascript
return product.base_price || 0;
```

---

## 📊 函数对比表

| 函数 | 输入 | 输出 | 用途 |
|-----|------|------|------|
| `calculatePrice` | 产品对象 + 数量 | 单价（Number） | 快速计算单价 |
| `getProductPriceInfo` | 产品对象 + 数量 | 详细价格对象 | 获取完整价格信息 |
| `calculateBulkPrice` | 产品数组 | 批量总价对象 | 计算多个产品总价 |

---

## ⚠️ 注意事项

### 1. 向后兼容

旧的调用方式仍然有效：
```javascript
// 旧方式（仍然支持）
const priceInfo = calculatePrice(priceTiers, quantity, priceType);

// 新方式（推荐）
const unitPrice = calculatePrice(product, quantity);
```

### 2. 返回值类型

- **新方式**: 返回 `Number`（单价）
- **旧方式**: 返回 `Object`（包含详细信息）

请根据实际需求选择调用方式。

### 3. 数据完整性

确保产品对象包含必要字段：
- `pricing_model`: 'fixed' 或 'tiered'
- `base_price`: 基础价格（必需）
- `price_tiers`: 价格档位数组（阶梯定价时必需）

### 4. 价格档位顺序

`price_tiers` 数组无需预先排序，函数会自动处理。但建议按 `min_quantity` 升序存储：
```javascript
price_tiers: [
  { min_quantity: 1, unit_price: 2500 },    // 最小档
  { min_quantity: 10, unit_price: 2300 },   // 中间档
  { min_quantity: 50, unit_price: 2100 }    // 最大档
]
```

---

## 🧪 测试示例

### 测试固定价格

```javascript
const { calculatePrice } = require('./utils/pricing');

const sfProduct = {
  model_base: 'SF025',
  pricing_model: 'fixed',
  base_price: 1200
};

console.log('数量 1:', calculatePrice(sfProduct, 1));   // 1200
console.log('数量 5:', calculatePrice(sfProduct, 5));   // 1200
console.log('数量 100:', calculatePrice(sfProduct, 100)); // 1200
```

### 测试阶梯价格

```javascript
const atProduct = {
  model_base: 'AT-SR52K8',
  pricing_model: 'tiered',
  base_price: 2500,
  price_tiers: [
    { min_quantity: 1, unit_price: 2500 },
    { min_quantity: 10, unit_price: 2300 },
    { min_quantity: 50, unit_price: 2100 }
  ]
};

console.log('数量 1:', calculatePrice(atProduct, 1));    // 2500
console.log('数量 5:', calculatePrice(atProduct, 5));    // 2500
console.log('数量 10:', calculatePrice(atProduct, 10));  // 2300
console.log('数量 15:', calculatePrice(atProduct, 15));  // 2300
console.log('数量 50:', calculatePrice(atProduct, 50));  // 2100
console.log('数量 100:', calculatePrice(atProduct, 100)); // 2100
```

### 测试边界情况

```javascript
// 情况1: 数量为 0（自动设为 1）
console.log('数量 0:', calculatePrice(atProduct, 0));    // 2500

// 情况2: 缺少 price_tiers（回退到 base_price）
const invalidProduct = {
  pricing_model: 'tiered',
  base_price: 3000
  // 缺少 price_tiers
};
console.log('无价格档位:', calculatePrice(invalidProduct, 10)); // 3000

// 情况3: 缺少 base_price
const noPriceProduct = {
  pricing_model: 'fixed'
  // 缺少 base_price
};
console.log('无基础价格:', calculatePrice(noPriceProduct, 5)); // 0
```

---

## 📚 相关文档

- **数据处理脚本**: `数据处理脚本更新报告.md`
- **快速参考**: `定价模式数据处理快速参考.md`
- **模型定义**: `backend/models/Actuator.js`
- **API 文档**: `API接口文档.md`

---

## 🚀 快速开始

### 1. 在 API 路由中使用

```javascript
const { calculatePrice } = require('../utils/pricing');

router.get('/products/:id/price', async (req, res) => {
  const product = await Product.findById(req.params.id);
  const unitPrice = calculatePrice(product, req.query.quantity);
  res.json({ unit_price: unitPrice });
});
```

### 2. 在选型算法中使用

```javascript
const unitPrice = calculatePrice(candidateProduct, requirements.quantity);
const score = calculateScore(candidateProduct, unitPrice, requirements);
```

### 3. 在前端显示价格

```javascript
const data = await fetchProductPrice(productId, quantity);
setUnitPrice(data.unit_price);
setTotalPrice(data.unit_price * quantity);
```

---

## ✅ 升级检查清单

- [ ] 更新所有调用 `calculatePrice` 的代码
- [ ] 测试固定价格产品的价格计算
- [ ] 测试阶梯价格产品的价格计算
- [ ] 验证 API 返回的价格正确
- [ ] 检查前端价格显示正常
- [ ] 测试批量计算功能
- [ ] 验证向后兼容性

---

**文档版本**: v1.0  
**更新日期**: 2025-10-28  
**维护者**: C-MAX 技术团队

