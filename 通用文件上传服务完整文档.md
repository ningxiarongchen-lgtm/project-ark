# 通用文件上传服务完整文档

**完成时间**: 2025年10月28日  
**状态**: ✅ 已完成并可用  
**支持**: Cloudinary云存储 + 本地存储

---

## 📋 项目概述

我们已经创建了一个完全可复用的文件上传服务，支持：
- ✅ **Cloudinary云存储** - 自动CDN加速
- ✅ **本地存储** - 无需外部服务
- ✅ **多种文件类型** - 图片、文档、压缩包等
- ✅ **文件夹管理** - 按模块分类存储
- ✅ **单文件/多文件上传**
- ✅ **文件删除功能**
- ✅ **完整的API接口**

---

## 🏗️ 文件结构

```
backend/
├── services/
│   └── upload.service.js       # 核心上传服务（新建）
├── routes/
│   └── uploadRoutes.js          # 通用上传路由（新建）
├── uploads/                     # 本地文件存储目录（自动创建）
│   ├── contracts/
│   ├── projects/
│   ├── purchase_orders/
│   └── uploads/
└── server.js                    # 已更新，注册新路由
```

---

## 🔧 安装依赖

### 必需依赖（已有）
```bash
npm install multer
```

### 可选依赖（Cloudinary云存储）
```bash
# 如果需要使用Cloudinary云存储
npm install cloudinary multer-storage-cloudinary
```

---

## ⚙️ 环境变量配置

在 `.env` 文件中添加以下配置：

```env
# 存储类型选择
# 设置为 'true' 使用Cloudinary云存储，否则使用本地存储
USE_CLOUDINARY=false

# Cloudinary配置（如果 USE_CLOUDINARY=true）
# 访问 https://cloudinary.com/ 注册账号获取以下信息
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret
```

### 配置说明

**本地存储模式（默认）**:
- 不需要额外配置
- 文件保存在 `backend/uploads/` 目录
- 通过 `/uploads/...` URL访问

**Cloudinary模式**:
- 需要注册Cloudinary账号
- 填写相应的配置信息
- 文件自动上传到云端
- 获得CDN加速的URL

---

## 📚 API文档

### 基础URL
```
http://localhost:5001/api/uploads
```

### 1. 上传单个文件

#### 通用接口
```http
POST /api/uploads/single
Authorization: Bearer {token}
Content-Type: multipart/form-data
Query Parameters:
  - folder: 文件夹名称（可选，默认：'uploads'）
  - storage: 存储类型（可选，'cloudinary' 或 'local'）
Body:
  - file: 要上传的文件（表单字段名必须是 'file'）
```

**请求示例（使用curl）**:
```bash
curl -X POST "http://localhost:5001/api/uploads/single?folder=contracts" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@/path/to/your/file.pdf"
```

**响应示例（本地存储）**:
```json
{
  "success": true,
  "message": "文件上传成功",
  "file": {
    "url": "/uploads/contracts/contract-1698765432123-123456789.pdf",
    "path": "/Users/.../backend/uploads/contracts/contract-1698765432123-123456789.pdf",
    "filename": "contract-1698765432123-123456789.pdf",
    "originalName": "contract.pdf",
    "mimeType": "application/pdf",
    "size": 245678,
    "storageType": "local"
  }
}
```

**响应示例（Cloudinary）**:
```json
{
  "success": true,
  "message": "文件上传成功",
  "file": {
    "url": "https://res.cloudinary.com/your-cloud/image/upload/v1234567890/contracts/file.pdf",
    "publicId": "contracts/file",
    "originalName": "contract.pdf",
    "mimeType": "application/pdf",
    "size": 245678,
    "storageType": "cloudinary"
  }
}
```

---

### 2. 上传多个文件

```http
POST /api/uploads/multiple
Authorization: Bearer {token}
Content-Type: multipart/form-data
Query Parameters:
  - folder: 文件夹名称（可选）
  - storage: 存储类型（可选）
Body:
  - files: 要上传的文件（表单字段名必须是 'files'，可多个）
```

**请求示例**:
```bash
curl -X POST "http://localhost:5001/api/uploads/multiple?folder=projects" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "files=@file1.jpg" \
  -F "files=@file2.pdf" \
  -F "files=@file3.docx"
```

**响应示例**:
```json
{
  "success": true,
  "message": "成功上传 3 个文件",
  "files": [
    {
      "url": "/uploads/projects/file1-123456789.jpg",
      "filename": "file1-123456789.jpg",
      "originalName": "file1.jpg",
      "mimeType": "image/jpeg",
      "size": 123456,
      "storageType": "local"
    },
    // ... 其他文件
  ]
}
```

---

### 3. 专用上传接口

系统预设了几个常用模块的专用接口：

#### 上传合同文件
```http
POST /api/uploads/contract
Authorization: Bearer {token}
Body: file (multipart/form-data)
```

#### 上传项目文件
```http
POST /api/uploads/project
Authorization: Bearer {token}
Body: file (multipart/form-data)
```

#### 上传采购订单文件
```http
POST /api/uploads/purchase-order
Authorization: Bearer {token}
Body: file (multipart/form-data)
```

**优势**:
- 无需指定folder参数
- 自动路由到对应文件夹
- 更简洁的API调用

---

### 4. 删除文件

```http
DELETE /api/uploads/:id
Authorization: Bearer {token}
Content-Type: application/json
Body:
  - publicId: Cloudinary文件ID（Cloudinary存储时使用）
  - path: 文件路径（本地存储时使用）
  - storageType: 存储类型（'cloudinary' 或 'local'）
```

**请求示例（删除本地文件）**:
```bash
curl -X DELETE "http://localhost:5001/api/uploads/file123" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "path": "/Users/.../backend/uploads/contracts/file.pdf",
    "storageType": "local"
  }'
```

**请求示例（删除Cloudinary文件）**:
```bash
curl -X DELETE "http://localhost:5001/api/uploads/file123" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "publicId": "contracts/file_abc123",
    "storageType": "cloudinary"
  }'
```

---

### 5. 获取上传配置信息

```http
GET /api/uploads/info
Authorization: Bearer {token}
```

**响应示例**:
```json
{
  "success": true,
  "config": {
    "storageType": "local",
    "maxFileSize": "10MB",
    "supportedFormats": [
      "jpg", "jpeg", "png", "gif", "webp",
      "pdf", "doc", "docx", "xls", "xlsx", "csv",
      "zip"
    ],
    "availableFolders": [
      "contracts",
      "projects",
      "purchase_orders",
      "uploads"
    ]
  }
}
```

---

## 💻 使用示例

### 示例1：在其他路由中使用上传服务

```javascript
// 在 orderRoutes.js 中
const { createUploadMiddleware, getFileInfo } = require('../services/upload.service');

// 创建订单时上传合同
router.post('/orders', protect, (req, res) => {
  const uploadMiddleware = createUploadMiddleware({
    folderName: 'contracts',
    storageType: process.env.USE_CLOUDINARY === 'true' ? 'cloudinary' : 'local'
  });
  
  uploadMiddleware(req, res, async (err) => {
    if (err) {
      return res.status(400).json({ message: '文件上传失败', error: err.message });
    }
    
    const fileInfo = getFileInfo(req.file);
    
    // 创建订单并保存文件信息
    const order = await Order.create({
      ...req.body,
      contractFile: fileInfo
    });
    
    res.json({ success: true, data: order });
  });
});
```

### 示例2：前端上传文件

#### 使用Fetch API
```javascript
async function uploadFile(file, folder = 'uploads') {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await fetch(
    `http://localhost:5001/api/uploads/single?folder=${folder}`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
      },
      body: formData
    }
  );
  
  const result = await response.json();
  return result.file;
}

// 使用
const fileInput = document.getElementById('fileInput');
const file = fileInput.files[0];
const fileInfo = await uploadFile(file, 'contracts');
console.log('文件URL:', fileInfo.url);
```

#### 使用Axios
```javascript
import axios from 'axios';

async function uploadFile(file, folder = 'uploads') {
  const formData = new FormData();
  formData.append('file', file);
  
  const response = await axios.post(
    `http://localhost:5001/api/uploads/single?folder=${folder}`,
    formData,
    {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'multipart/form-data'
      }
    }
  );
  
  return response.data.file;
}
```

#### React组件示例
```jsx
import React, { useState } from 'react';
import { Upload, Button, message } from 'antd';
import { UploadOutlined } from '@ant-design/icons';
import axios from 'axios';

const FileUploader = ({ folder = 'uploads', onSuccess }) => {
  const [uploading, setUploading] = useState(false);
  
  const handleUpload = async (options) => {
    const { file, onSuccess: onSuccessCallback, onError } = options;
    
    const formData = new FormData();
    formData.append('file', file);
    
    setUploading(true);
    try {
      const response = await axios.post(
        `http://localhost:5001/api/uploads/single?folder=${folder}`,
        formData,
        {
          headers: {
            'Authorization': `Bearer ${localStorage.getItem('token')}`,
            'Content-Type': 'multipart/form-data'
          }
        }
      );
      
      message.success('文件上传成功');
      onSuccessCallback(response.data.file);
      onSuccess && onSuccess(response.data.file);
    } catch (error) {
      message.error('文件上传失败');
      onError(error);
    } finally {
      setUploading(false);
    }
  };
  
  return (
    <Upload
      customRequest={handleUpload}
      showUploadList={true}
      maxCount={1}
    >
      <Button icon={<UploadOutlined />} loading={uploading}>
        上传文件
      </Button>
    </Upload>
  );
};

export default FileUploader;
```

---

## 🎯 支持的文件类型

### 图片文件
- `.jpg`, `.jpeg` - JPEG图片
- `.png` - PNG图片
- `.gif` - GIF动图
- `.webp` - WebP图片

### 文档文件
- `.pdf` - PDF文档
- `.doc`, `.docx` - Word文档
- `.xls`, `.xlsx` - Excel表格
- `.csv` - CSV文件

### 压缩文件
- `.zip` - ZIP压缩包

### 文件大小限制
- 默认：10MB
- 可通过配置调整

---

## 📁 文件夹组织

系统预设了以下文件夹：

```
backend/uploads/
├── contracts/           # 合同文件
├── projects/            # 项目文件
├── purchase_orders/     # 采购订单文件
└── uploads/             # 通用上传文件
```

### 添加自定义文件夹

只需在上传时指定folder参数，系统会自动创建：

```javascript
// 上传到自定义文件夹
const uploadMiddleware = createUploadMiddleware({
  folderName: 'invoices',  // 发票文件夹
  storageType: 'local'
});
```

---

## 🔐 安全特性

1. **认证保护**
   - 所有上传接口需要JWT认证
   - 使用 `protect` 中间件验证token

2. **文件类型限制**
   - 只允许预定义的安全文件类型
   - 防止上传可执行文件

3. **文件大小限制**
   - 默认限制10MB
   - 防止服务器存储被占满

4. **文件名安全**
   - 自动生成唯一文件名
   - 防止文件名冲突和注入攻击

---

## 🚀 快速开始

### 1. 使用本地存储（默认）

**步骤1**: 确认配置
```env
USE_CLOUDINARY=false
```

**步骤2**: 启动服务器
```bash
cd backend
npm start
```

**步骤3**: 测试上传
```bash
curl -X POST "http://localhost:5001/api/uploads/single" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@test.jpg"
```

**步骤4**: 访问文件
```
http://localhost:5001/uploads/uploads/test-123456789.jpg
```

---

### 2. 使用Cloudinary云存储

**步骤1**: 安装依赖
```bash
npm install cloudinary multer-storage-cloudinary
```

**步骤2**: 注册Cloudinary账号
- 访问 https://cloudinary.com/
- 注册免费账号
- 获取配置信息（Dashboard页面）

**步骤3**: 配置环境变量
```env
USE_CLOUDINARY=true
CLOUDINARY_CLOUD_NAME=your_cloud_name
CLOUDINARY_API_KEY=your_api_key
CLOUDINARY_API_SECRET=your_api_secret
```

**步骤4**: 重启服务器
```bash
npm start
```

**步骤5**: 测试上传
```bash
curl -X POST "http://localhost:5001/api/uploads/single" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -F "file=@test.jpg"
```

**步骤6**: 文件会自动上传到Cloudinary
- 返回的URL直接可用
- 自动获得CDN加速

---

## 🎨 高级配置

### 自定义文件过滤器

```javascript
const { createUploadMiddleware } = require('../services/upload.service');

// 只允许图片
const imageFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('只允许上传图片'), false);
  }
};

const uploadMiddleware = createUploadMiddleware({
  folderName: 'avatars',
  storageType: 'cloudinary',
  fileFilter: imageFilter
});
```

### 调整文件大小限制

```javascript
const uploadMiddleware = createUploadMiddleware({
  folderName: 'videos',
  storageType: 'cloudinary',
  maxSize: 50 * 1024 * 1024  // 50MB
});
```

### 支持多文件上传

```javascript
const uploadMiddleware = createUploadMiddleware({
  folderName: 'gallery',
  storageType: 'cloudinary',
  multiple: true  // 启用多文件上传
});
```

---

## 📊 对比：本地存储 vs Cloudinary

| 特性 | 本地存储 | Cloudinary |
|------|---------|-----------|
| **费用** | 免费（使用自己的服务器） | 免费套餐有限额 |
| **CDN** | ❌ 无 | ✅ 全球CDN |
| **存储容量** | 受服务器限制 | 云端无限（付费） |
| **图片处理** | ❌ 需自己实现 | ✅ 自动优化、裁剪、转换 |
| **备份** | ❌ 需自己备份 | ✅ 自动备份 |
| **服务器负载** | ⚠️ 消耗服务器资源 | ✅ 减轻服务器负担 |
| **配置复杂度** | ✅ 简单 | ⚠️ 需注册配置 |
| **适用场景** | 开发环境、小型项目 | 生产环境、大型项目 |

---

## 🐛 常见问题

### Q1: 上传文件返回403错误
**原因**: 未提供认证token或token过期  
**解决**: 检查请求头中是否包含有效的 `Authorization: Bearer {token}`

### Q2: 文件上传后无法访问（本地存储）
**原因**: 静态文件服务未配置  
**解决**: 确认 `server.js` 中已添加:
```javascript
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
```

### Q3: Cloudinary上传失败
**原因**: 环境变量未配置或包未安装  
**解决**: 
1. 检查 `.env` 配置
2. 确认已安装 `cloudinary` 和 `multer-storage-cloudinary`

### Q4: 不支持的文件类型
**原因**: 文件类型不在允许列表中  
**解决**: 修改 `upload.service.js` 中的 `fileFilter` 函数

---

## 📝 最佳实践

### 1. 文件命名
```javascript
// ✅ 好的做法：自动生成唯一文件名
// 系统会自动添加时间戳和随机数

// ❌ 避免：直接使用用户上传的文件名
// 可能导致文件名冲突和安全问题
```

### 2. 存储选择
```javascript
// 开发环境：使用本地存储
if (process.env.NODE_ENV === 'development') {
  storageType = 'local';
}

// 生产环境：使用Cloudinary
if (process.env.NODE_ENV === 'production') {
  storageType = 'cloudinary';
}
```

### 3. 错误处理
```javascript
try {
  const fileInfo = await uploadFile(file);
  // 保存到数据库
  await saveToDatabase(fileInfo);
} catch (error) {
  // 如果保存失败，删除已上传的文件
  if (fileInfo.storageType === 'cloudinary') {
    await deleteCloudinaryFile(fileInfo.publicId);
  } else {
    await deleteLocalFile(fileInfo.path);
  }
  throw error;
}
```

### 4. 进度显示
```javascript
// 前端显示上传进度
const formData = new FormData();
formData.append('file', file);

axios.post('/api/uploads/single', formData, {
  onUploadProgress: (progressEvent) => {
    const percentCompleted = Math.round(
      (progressEvent.loaded * 100) / progressEvent.total
    );
    console.log(`上传进度: ${percentCompleted}%`);
  }
});
```

---

## 🔄 迁移指南

### 从旧的上传逻辑迁移

**旧代码**:
```javascript
// orders.routes.js (假设的旧代码)
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

router.post('/upload', upload.single('file'), (req, res) => {
  // 处理上传
});
```

**新代码**:
```javascript
// orders.routes.js (使用新服务)
const { createUploadMiddleware, getFileInfo } = require('../services/upload.service');

router.post('/upload', protect, (req, res) => {
  const uploadMiddleware = createUploadMiddleware({
    folderName: 'orders',
    storageType: process.env.USE_CLOUDINARY === 'true' ? 'cloudinary' : 'local'
  });
  
  uploadMiddleware(req, res, (err) => {
    if (err) {
      return res.status(400).json({ message: err.message });
    }
    
    const fileInfo = getFileInfo(req.file);
    res.json({ success: true, file: fileInfo });
  });
});
```

**或者直接使用通用接口**:
```javascript
// 前端代码
const response = await axios.post('/api/uploads/single?folder=orders', formData);
```

---

## 📚 相关文档

- **Multer文档**: https://github.com/expressjs/multer
- **Cloudinary文档**: https://cloudinary.com/documentation
- **Express静态文件**: https://expressjs.com/en/starter/static-files.html

---

## 🎉 总结

通过这次重构，我们实现了：

✅ **统一的文件上传服务** - 一处配置，到处使用  
✅ **灵活的存储选择** - 本地或云端，按需切换  
✅ **完整的API接口** - 开箱即用  
✅ **高度可复用** - 轻松扩展到新模块  
✅ **生产环境就绪** - 支持Cloudinary CDN  

**文件清单**:
- ✅ `backend/services/upload.service.js` - 核心服务
- ✅ `backend/routes/uploadRoutes.js` - API路由
- ✅ `backend/server.js` - 已更新
- ✅ 本文档

**下一步**:
1. 如需使用Cloudinary，安装依赖并配置环境变量
2. 在其他模块中替换旧的上传逻辑
3. 更新前端调用新的API接口

---

**文档版本**: v1.0  
**最后更新**: 2025年10月28日  
**作者**: Cursor AI Assistant

