# 价格计算函数替换完成报告

## 项目概述

本次升级将后端代码中所有分散的价格计算逻辑统一替换为 `utils/pricing.js` 中的标准 `calculatePrice` 函数，实现了：
- ✅ 价格计算逻辑的集中管理
- ✅ 阶梯定价功能的统一支持
- ✅ 代码复用和维护性提升
- ✅ 向后兼容性保证

---

## 修改文件清单

### 1. 控制器层 (Controllers)

#### 1.1 `controllers/selectionController.js`
**修改位置：**
- 第3行：引入 `calculatePrice` 函数
  ```javascript
  const { calculatePrice } = require('../utils/pricing');
  ```

- 第232-260行：**SF 系列（Scotch Yoke）温度代码价格调整**
  - **旧逻辑：** 直接使用 `actuator.base_price`，温度代码上浮 5%
  - **新逻辑：** 
    1. 优先使用阶梯定价 `calculatePrice(actuator.price_tiers, 1, 'normal')`
    2. 降级到 `base_price`
    3. 应用温度代码调整（如需要）
  
- 第389-455行：**AT/GY 系列（Rack & Pinion）价格计算**
  - **旧逻辑：** 使用 `actuator.pricing` 对象的不同温度价格
  - **新逻辑：**
    1. 映射温度类型到价格类型（low → low_temp, high → high_temp）
    2. 优先使用阶梯定价 `calculatePrice(actuator.price_tiers, 1, priceType)`
    3. 降级到 `actuator.pricing` 或 `base_price`
    4. 添加手轮价格（如需要）

#### 1.2 `controllers/newProjectController.js`
**修改位置：**
- 第4-5行：引入 `Accessory` 模型和 `calculatePrice` 函数
  ```javascript
  const Accessory = require('../models/Accessory');
  const { calculatePrice } = require('../utils/pricing');
  ```

- 第426-481行：**配件总价计算逻辑**
  - **旧逻辑：** 简单的 `unit_price × quantity`
  - **新逻辑：**
    1. 检查配件是否有 `price_tiers`
    2. 如有，使用 `calculatePrice(acc.price_tiers, quantity, 'normal')`
    3. 否则使用单一价格计算
    4. 支持未来配件阶梯定价扩展

#### 1.3 `controllers/quoteController.js`
**修改位置：**
- 第5行：引入 `calculatePrice` 函数
  ```javascript
  const { calculatePrice } = require('../utils/pricing');
  ```

- 第78-194行：**报价单价格计算逻辑**
  - **产品价格计算：**
    - **旧逻辑：** 使用 `product.pricing.basePrice` 和 `discountTiers`（百分比折扣）
    - **新逻辑：**
      1. 优先使用阶梯定价 `calculatePrice(product.price_tiers, quantity, 'normal')`
      2. 自动计算折扣率（相对于基础价格）
      3. 降级到旧的 `pricing.basePrice` 和 `discountTiers`
      4. 最终降级到 `base_price`
  
  - **配件价格计算：**
    - **旧逻辑：** 使用 `accessory.pricing.basePrice`
    - **新逻辑：**
      1. 优先使用阶梯定价 `calculatePrice(accessory.price_tiers, quantity, 'normal')`
      2. 降级到 `pricing.basePrice` 或 `price`

---

### 2. 模型层 (Models)

#### 2.1 `models/Actuator.js`
**修改位置：**
- 第2行：引入 `calculatePrice` 和 `getAllPriceTiers` 函数
  ```javascript
  const { calculatePrice, getAllPriceTiers } = require('../utils/pricing');
  ```

- 第278-288行：**重构 `getPriceByQuantity` 方法**
  - **旧逻辑：** 本地实现完整的阶梯定价逻辑（40+ 行代码）
  - **新逻辑：** 调用统一的 `calculatePrice` 函数（3 行代码）
  ```javascript
  actuatorSchema.methods.getPriceByQuantity = function(quantity, priceType = 'normal') {
    if (!this.price_tiers || this.price_tiers.length === 0) {
      return null;
    }
    return calculatePrice(this.price_tiers, quantity, priceType);
  };
  ```

- 第290-299行：**重构 `getAllPriceTiers` 方法**
  - **旧逻辑：** 本地实现档位筛选和排序（15+ 行代码）
  - **新逻辑：** 调用统一的 `getAllPriceTiers` 函数（3 行代码）
  ```javascript
  actuatorSchema.methods.getAllPriceTiers = function(priceType = null) {
    if (!this.price_tiers || this.price_tiers.length === 0) {
      return [];
    }
    return getAllPriceTiers(this.price_tiers, priceType);
  };
  ```

#### 2.2 `models/NewProject.js`
**修改位置：**
- 第2行：引入 `calculatePrice` 函数
  ```javascript
  const { calculatePrice } = require('../utils/pricing');
  ```

- 第483-516行：**`addAccessoryToSelection` 方法**
  - **旧逻辑：** 简单的 `unit_price × quantity`
  - **新逻辑：** 支持阶梯定价
    1. 检查 `accessoryData.price_tiers`
    2. 使用 `calculatePrice` 计算
    3. 降级到单一价格

- 第528-572行：**`calculateSelectionPrice` 方法**
  - **旧逻辑：** 简单的 `unit_price × quantity`
  - **新逻辑：** 支持阶梯定价
    1. 优先使用已有的 `total_price`
    2. 如未设置，尝试使用 `price_tiers` 和 `calculatePrice`
    3. 降级到单一价格计算

---

## 技术亮点

### 1. 阶梯定价支持
所有价格计算现在都支持基于数量的阶梯定价：
```javascript
const priceTiers = [
  { min_quantity: 1, unit_price: 5280, price_type: 'normal' },
  { min_quantity: 5, unit_price: 5016, price_type: 'normal' },
  { min_quantity: 10, unit_price: 4752, price_type: 'normal' }
];

const priceInfo = calculatePrice(priceTiers, 8);
// 返回: { unit_price: 5016, total_price: 40128, ... }
```

### 2. 多温度类型支持
- **SF 系列：** 温度代码（'No code', 'T1', 'T2', 'T3', 'M'）+ 5% 价格调整
- **AT/GY 系列：** 温度类型（'normal', 'low_temp', 'high_temp'）直接映射到不同的价格档位

### 3. 向后兼容性
所有修改都包含多级降级方案：
1. 优先使用新的 `price_tiers` 阶梯定价
2. 降级到旧的 `pricing` 对象
3. 最终降级到 `base_price` 或 `price`

这确保了即使数据库中的数据还没有完全迁移到新格式，系统也能正常运行。

### 4. 代码复用
- **删除重复代码：** Actuator 模型中的价格计算方法从 ~60 行减少到 ~10 行
- **集中管理：** 所有价格计算逻辑集中在 `utils/pricing.js`
- **易于维护：** 修改价格计算规则只需要在一个地方修改

---

## 价格计算流程图

### SF 系列（Scotch Yoke）
```
阀门扭矩 × 安全系数 = 需求扭矩
    ↓
查找合适的执行器
    ↓
计算基础价格:
  - 有 price_tiers？ → calculatePrice(price_tiers, 1, 'normal')
  - 否则 → base_price
    ↓
应用温度代码调整:
  - 温度代码 ≠ 'No code'？ → 价格 × 1.05
    ↓
添加手动操作装置价格（如需要）
    ↓
最终价格
```

### AT/GY 系列（Rack & Pinion）
```
阀门扭矩 × 安全系数 = 需求扭矩
    ↓
查找合适的执行器
    ↓
映射温度类型:
  - 'low' → 'low_temp'
  - 'high' → 'high_temp'
  - 'normal' → 'normal'
    ↓
计算基础价格:
  - 有 price_tiers？ → calculatePrice(price_tiers, 1, priceType)
  - 否则 → pricing.base_price_xxx 或 base_price
    ↓
添加手轮价格（如需要）
    ↓
最终价格
```

### 配件价格计算
```
配件数据 + 数量
    ↓
有 price_tiers？
  - 是 → calculatePrice(price_tiers, quantity, 'normal')
  - 否 → unit_price × quantity
    ↓
总价
```

---

## 测试建议

### 1. 单元测试
- ✅ `utils/pricing.test.js` 已存在
- 建议添加：控制器层和模型层的价格计算测试

### 2. 集成测试
测试场景：
1. **SF 系列选型：**
   - 无温度代码
   - 有温度代码（T1, T2, T3, M）
   - 有阶梯定价
   - 无阶梯定价（降级到 base_price）

2. **AT/GY 系列选型：**
   - 常温型（normal）
   - 低温型（low_temp）
   - 高温型（high_temp）
   - 有手轮
   - 无手轮

3. **报价生成：**
   - 单个产品
   - 多个产品
   - 产品 + 配件
   - 不同数量（测试阶梯定价）

4. **项目管理：**
   - 添加选型配置
   - 添加配件到选型
   - 计算选型总价

### 3. 回归测试
- 使用现有数据测试所有价格计算功能
- 验证价格计算结果与之前版本一致
- 测试边缘情况（数量 = 0, 负数, 超大数量）

---

## API 端点测试

### 1. 选型计算
```bash
POST /api/selection/calculate
{
  "valveTorque": 100,
  "safetyFactor": 1.3,
  "working_pressure": 0.6,
  "mechanism": "Scotch Yoke",
  "valveType": "Ball Valve",
  "temperature_code": "T1"
}
```

### 2. 自动选型
```bash
POST /api/new-projects/:id/auto-select
{
  "tag_number": "V-001",
  "input_params": {...},
  "selected_actuator": {...},
  "selected_accessories": [
    {
      "_id": "...",
      "quantity": 5,
      "price_tiers": [...]
    }
  ]
}
```

### 3. 报价生成
```bash
POST /api/quotes
{
  "projectId": "..."
}
```

---

## 性能优化

### 优化点
1. **减少代码重复：** 从多处独立实现变为单一函数调用
2. **降低维护成本：** 价格计算规则集中管理
3. **提高可扩展性：** 新的价格类型只需在 `pricing.js` 中添加

### 性能影响
- **计算性能：** 无明显影响（算法复杂度相同）
- **内存使用：** 略有减少（减少代码重复）
- **数据库查询：** 无变化

---

## 数据迁移建议

### 当前兼容性
系统现在支持三种价格格式：
1. **新格式：** `price_tiers` 数组（阶梯定价）
2. **中间格式：** `pricing` 对象（多温度价格）
3. **旧格式：** `base_price` 字段（单一价格）

### 迁移步骤（建议）
1. **Phase 1：** 保持当前状态，三种格式共存（✅ 已完成）
2. **Phase 2：** 逐步为产品和配件添加 `price_tiers` 数据
3. **Phase 3：** 数据迁移脚本：将 `base_price` 和 `pricing` 转换为 `price_tiers`
4. **Phase 4：** 移除旧格式支持（可选）

### 迁移脚本示例
```javascript
// 将旧的 base_price 转换为 price_tiers
const convertToPriceTiers = (basePrice) => {
  return [
    { min_quantity: 1, unit_price: basePrice, price_type: 'normal' },
    { min_quantity: 5, unit_price: basePrice * 0.95, price_type: 'normal' },
    { min_quantity: 10, unit_price: basePrice * 0.90, price_type: 'normal' },
    { min_quantity: 20, unit_price: basePrice * 0.85, price_type: 'normal' }
  ];
};
```

---

## 总结

### 完成的工作
✅ 替换了 5 个文件中的所有价格计算逻辑  
✅ 集中管理价格计算到 `utils/pricing.js`  
✅ 支持阶梯定价和多温度类型  
✅ 保持向后兼容性  
✅ 减少代码重复  
✅ 通过 linter 检查  

### 代码统计
- **修改文件：** 5 个
- **新增引用：** 5 处
- **替换价格计算逻辑：** 8 处
- **删除重复代码：** ~100 行
- **新增代码：** ~150 行
- **净增长：** ~50 行（但功能更强大）

### 下一步建议
1. ⏭️ 运行完整的回归测试套件
2. ⏭️ 在测试环境验证所有价格计算功能
3. ⏭️ 准备数据迁移脚本（可选）
4. ⏭️ 更新 API 文档（如需要）
5. ⏭️ 培训团队成员使用新的价格计算函数

---

**报告生成时间：** 2025-10-27  
**版本：** v2.0  
**作者：** C-MAX 技术团队

