# 后端安全加固快速参考

## 🔑 JWT配置

### 环境变量 (.env)
```env
# 访问令牌（8小时）
JWT_SECRET=5d3bcb03a8407d6a9a76f03c3c852d386184aea8f2dd4c34f9e2e026dfcb975476e1e18ae0b6febe39dc11c8da7524fcbbcc6a701661eb230ea21fc93a0ff16e
JWT_EXPIRE=8h

# 刷新令牌（7天）
REFRESH_TOKEN_SECRET=a7c4f9e2b8d6013ae5c7f1b4d8e9a2c6f3b7e1d5a9c4f8e2b6d0a3e7c1f5b9d8e3a7c2f6b1d5e9a4c8f3b7e2d6a1c5e9f4b8d3a7c2e6f1b5d9a4c8e3f7b2d6a1e5
REFRESH_TOKEN_EXPIRE=7d
```

### 生成新密钥
```bash
# 在backend目录执行
node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"
```

---

## 🚪 登录与Token管理

### 登录 API
```http
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123"
}
```

**响应**:
```json
{
  "_id": "user_id",
  "name": "张三",
  "email": "user@example.com",
  "role": "Sales Engineer",
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." // 向后兼容
}
```

### 刷新Token
```http
POST /api/auth/refresh-token
Content-Type: application/json

{
  "refreshToken": "your_refresh_token_here"
}
```

**响应**:
```json
{
  "accessToken": "new_access_token",
  "refreshToken": "new_refresh_token",
  "token": "new_access_token"
}
```

### 登出
```http
POST /api/auth/logout
Authorization: Bearer <accessToken>
```

### 查看活跃会话
```http
GET /api/auth/sessions
Authorization: Bearer <accessToken>
```

---

## 👥 系统角色

| 角色 | 英文名称 | 主要权限 |
|------|---------|----------|
| 系统管理员 | Administrator | 所有权限 |
| 销售经理 | Sales Manager | 所有销售资源 + 审批 |
| 销售工程师 | Sales Engineer | 销售相关操作（自己的） |
| 技术工程师 | Technical Engineer | 技术相关操作（自己的） |
| 采购专员 | Procurement Specialist | 采购订单管理 |
| 生产计划员 | Production Planner | 生产管理 |
| 售后工程师 | After-sales Engineer | 售后服务 |

---

## 🔒 权限控制中间件

### protect - 验证Token
```javascript
const { protect } = require('../middleware/auth');

// 确保用户已登录
router.get('/api/projects', protect, getProjects);
```

### authorize - 验证角色
```javascript
const { authorize } = require('../middleware/auth');

// 只允许特定角色访问
router.post('/api/projects', 
  protect, 
  authorize('Technical Engineer', 'Sales Engineer', 'Administrator'),
  createProject
);

// 只允许管理员
router.delete('/api/projects/:id',
  protect,
  authorize('Administrator'),
  deleteProject
);
```

### 所有权校验
```javascript
const { checkProjectOwnership } = require('../middleware/ownership');

// 确保用户只能修改自己的项目
router.put('/api/projects/:id',
  protect,
  authorize('Technical Engineer', 'Sales Engineer', 'Administrator'),
  checkProjectOwnership, // 所有权校验
  updateProject
);
```

---

## 📋 所有权中间件列表

| 中间件 | 用途 | 特权角色 |
|--------|------|----------|
| `checkProjectOwnership` | 项目所有权 | Administrator, Sales Manager |
| `checkOrderOwnership` | 订单所有权 | Administrator, Sales Manager |
| `checkPurchaseOrderOwnership` | 采购订单所有权 | Administrator |
| `checkTicketOwnership` | 工单所有权 | Administrator, Sales Manager |
| `checkProductionOrderOwnership` | 生产订单所有权 | Administrator |

### 使用示例
```javascript
const { 
  checkProjectOwnership,
  checkOrderOwnership,
  checkTicketOwnership 
} = require('../middleware/ownership');

// 项目更新 - 需要所有权
router.put('/projects/:id', protect, authorize(...), checkProjectOwnership, updateProject);

// 订单修改 - 需要所有权
router.put('/orders/:id', protect, authorize(...), checkOrderOwnership, updateOrder);

// 工单处理 - 创建者或被分配者
router.put('/tickets/:id', protect, authorize(...), checkTicketOwnership, updateTicket);
```

---

## 🎯 常见权限配置模式

### 模式1: 公开读，限制写
```javascript
// 所有认证用户可读
router.get('/api/products', protect, getProducts);

// 只有管理员可创建/修改/删除
router.post('/api/products', protect, authorize('Administrator'), createProduct);
router.put('/api/products/:id', protect, authorize('Administrator'), updateProduct);
router.delete('/api/products/:id', protect, authorize('Administrator'), deleteProduct);
```

### 模式2: 角色限制 + 所有权控制
```javascript
// 多角色可创建
router.post('/api/projects', 
  protect,
  authorize('Technical Engineer', 'Sales Engineer', 'Sales Manager', 'Administrator'),
  createProject
);

// 多角色可修改，但需要所有权
router.put('/api/projects/:id',
  protect,
  authorize('Technical Engineer', 'Sales Engineer', 'Sales Manager', 'Administrator'),
  checkProjectOwnership, // 非管理员只能修改自己的
  updateProject
);

// 只有管理员可删除
router.delete('/api/projects/:id',
  protect,
  authorize('Administrator'),
  deleteProject
);
```

### 模式3: 审批流程
```javascript
// 创建订单
router.post('/api/orders',
  protect,
  authorize('Sales Engineer', 'Sales Manager', 'Administrator'),
  createOrder
);

// 修改订单 - 需要所有权
router.put('/api/orders/:id',
  protect,
  authorize('Sales Engineer', 'Sales Manager', 'Administrator'),
  checkOrderOwnership,
  updateOrder
);

// 审批订单 - 只有经理/管理员
router.post('/api/orders/:id/approve',
  protect,
  authorize('Sales Manager', 'Administrator'),
  approveOrder
);
```

---

## 🛡️ 安全最佳实践

### 1. Token存储（前端）
```javascript
// ✅ 推荐：HttpOnly Cookie（最安全）
// 需要后端配置cookie选项

// ✅ 可选：localStorage（较安全，需防XSS）
localStorage.setItem('accessToken', token);
localStorage.setItem('refreshToken', refreshToken);

// ❌ 不推荐：sessionStorage（仅单标签页有效）
// ❌ 禁止：全局变量（极不安全）
```

### 2. API请求配置
```javascript
// Axios全局配置
import axios from 'axios';

const api = axios.create({
  baseURL: 'http://localhost:5000/api',
  timeout: 10000
});

// 请求拦截器 - 自动添加token
api.interceptors.request.use(config => {
  const token = localStorage.getItem('accessToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器 - 自动刷新token
api.interceptors.response.use(
  response => response,
  async error => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = localStorage.getItem('refreshToken');
        const { data } = await axios.post('/api/auth/refresh-token', { refreshToken });
        
        localStorage.setItem('accessToken', data.accessToken);
        localStorage.setItem('refreshToken', data.refreshToken);
        
        originalRequest.headers.Authorization = `Bearer ${data.accessToken}`;
        return api(originalRequest);
      } catch (err) {
        // 刷新失败，跳转登录
        localStorage.clear();
        window.location.href = '/login';
      }
    }
    
    return Promise.reject(error);
  }
);

export default api;
```

### 3. 权限拒绝处理
```javascript
// 处理403错误（权限不足）
api.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 403) {
      // 显示权限不足提示
      alert('您没有权限执行此操作');
      
      // 或显示详细信息
      const { message, reason } = error.response.data;
      if (reason === 'ownership_violation') {
        alert('您只能修改自己创建的资源');
      }
    }
    return Promise.reject(error);
  }
);
```

### 4. 生产环境清单
- [ ] 更换强随机JWT密钥
- [ ] 启用HTTPS
- [ ] .env文件不提交到Git
- [ ] 配置CORS白名单
- [ ] 设置合理的token过期时间
- [ ] 启用速率限制
- [ ] 配置日志审计
- [ ] 定期密钥轮换

---

## 🧪 测试命令

### 测试登录
```bash
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@example.com","password":"admin123"}'
```

### 测试刷新Token
```bash
curl -X POST http://localhost:5000/api/auth/refresh-token \
  -H "Content-Type: application/json" \
  -d '{"refreshToken":"YOUR_REFRESH_TOKEN"}'
```

### 测试受保护路由
```bash
curl -X GET http://localhost:5000/api/projects \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN"
```

### 测试所有权保护（应该返回403）
```bash
# 用户A的token尝试修改用户B的项目
curl -X PUT http://localhost:5000/api/projects/USER_B_PROJECT_ID \
  -H "Authorization: Bearer USER_A_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"Modified Name"}'
```

---

## ❓ 常见问题

### Q1: Token过期了怎么办？
**A**: 前端使用refreshToken自动刷新accessToken，用户无感知。如果refreshToken也过期，需要重新登录。

### Q2: 如何判断用户是否有权限？
**A**: 
1. 检查`req.user.role`是否在允许的角色列表中
2. 检查`req.user._id`是否与资源的`createdBy`匹配
3. Administrator和部分Manager角色拥有特权

### Q3: 修改他人资源返回什么错误？
**A**: 返回403 Forbidden，响应包含:
```json
{
  "message": "Access denied. You can only modify resources you created.",
  "reason": "ownership_violation"
}
```

### Q4: 如何添加新角色？
**A**:
1. 在`backend/models/User.js`的role枚举中添加
2. 在相关路由的`authorize()`中添加该角色
3. 如需特权，在所有权中间件中添加逻辑

### Q5: 生产环境如何更换密钥？
**A**:
1. 生成新密钥：`node -e "console.log(require('crypto').randomBytes(64).toString('hex'))"`
2. 更新`.env`文件的`JWT_SECRET`和`REFRESH_TOKEN_SECRET`
3. 重启服务器
4. **注意**: 所有用户需要重新登录

---

## 📞 获取帮助

- **详细文档**: 查看《后端安全加固完成报告.md》
- **代码示例**: 参考现有路由文件（如`projectRoutes.js`）
- **测试**: 运行 `npm test` 执行自动化测试

**文档版本**: v1.0 (2025-10-28)

